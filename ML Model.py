# -*- coding: utf-8 -*-
"""AgriTech.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ierQGtXZbBK5ozoZ_6s-JCO4SnbaFkeI
"""

import pandas as pd
import numpy as np
import joblib
import matplotlib.pyplot as plt
import seaborn as sns

from sklearn.model_selection import train_test_split
from sklearn.preprocessing import LabelEncoder
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import confusion_matrix, accuracy_score, precision_score, recall_score  # ✅ Import fixed!


# Load Dataset
file_path = "/content/Final_DataSet_Agritech.csv"
df = pd.read_csv(file_path)

print(df.columns.tolist())


# Convert all categorical data to lowercase to avoid case mismatches
df["Crop"] = df["Crop"].str.lower()
df["soil_type"] = df["soil_type"].str.lower()
df["Seedling Stage"] = df["Seedling Stage"].str.lower()

# Encode categorical features
label_encoders = {}
for col in ["Crop", "soil_type", "Seedling Stage"]:
    le = LabelEncoder()
    df[col] = le.fit_transform(df[col])
    label_encoders[col] = le

# Splitting Data
X = df.drop(columns=["Irrigation"])
y = df["Irrigation"]

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Train Model
model = RandomForestClassifier(n_estimators=100, random_state=42)
model.fit(X_train, y_train)

# Save Model & Encoders
joblib.dump(model, "irrigation_model.pkl")
joblib.dump(label_encoders, "label_encoders.pkl")

# ✅ Compute Performance Metrics (Fix applied!)
y_pred = model.predict(X_test)

conf_matrix = confusion_matrix(y_test, y_pred)
accuracy = accuracy_score(y_test, y_pred)
precision = precision_score(y_test, y_pred, average="macro")  # FIXED
recall = recall_score(y_test, y_pred, average="macro")  # FIXED

# Display Metrics
print(f"✅ Accuracy: {accuracy:.2f}")
print(f"🎯 Precision: {precision:.2f}")
print(f"🔁 Recall: {recall:.2f}")

# Plot Confusion Matrix
plt.figure(figsize=(6, 4))
sns.heatmap(conf_matrix, annot=True, fmt="d", cmap="Blues", xticklabels=np.unique(y), yticklabels=np.unique(y))
plt.xlabel("Predicted Label")
plt.ylabel("True Label")
plt.title("Confusion Matrix")
plt.show()


# Function to Take User Input and Predict Continuously
def predict_irrigation():
    print("\n🌱 Continuous Irrigation Prediction System 🌱\n")

    # Load the model and encoders
    model = joblib.load("irrigation_model.pkl")
    label_encoders = joblib.load("label_encoders.pkl")

    # Get valid categories from training data
    valid_crops = list(label_encoders["Crop"].classes_)
    valid_soils = list(label_encoders["soil_type"].classes_)
    valid_stages = list(label_encoders["Seedling Stage"].classes_)

    while True:
        print("\n🌾 Enter Crop Details for Prediction (or type 'exit' to quit) 🌾\n")

        # Taking user inputs (convert input to lowercase for consistency)
        crop = input(f"Enter Crop ID {valid_crops}: ").strip().lower()
        if crop == "exit":
            print("\n👋 Exiting... Have a great day! 🌿\n")
            break

        soil = input(f"Enter Soil Type {valid_soils}: ").strip().lower()
        stage = input(f"Enter Seedling Stage {valid_stages}: ").strip().lower()

        try:
            moi = float(input("Enter Soil Moisture (MOI) percentage: "))
            temp = float(input("Enter Temperature (°C): "))
            humidity = float(input("Enter Humidity percentage: "))
        except ValueError:
            print("\n❌ Error: Please enter valid numeric values for MOI, Temperature, and Humidity!\n")
            continue

        # Check if user inputs are valid
        if crop not in valid_crops or soil not in valid_soils or stage not in valid_stages:
            print("\n❌ Error: Invalid input! Please enter a valid Crop ID, Soil Type, or Seedling Stage.\n")
            continue

        # Encode categorical inputs
        crop_encoded = label_encoders["Crop"].transform([crop])[0]
        soil_encoded = label_encoders["soil_type"].transform([soil])[0]
        stage_encoded = label_encoders["Seedling Stage"].transform([stage])[0]

        # Creating input array for prediction
        input_data = np.array([[crop_encoded, soil_encoded, stage_encoded, moi, temp, humidity]])

        # Predicting irrigation requirement
        prediction = model.predict(input_data)[0]
        result = "✅ Irrigation Required" if prediction == 1 else "❌ No Irrigation Needed"

        print(f"\n🌾 Prediction: {result} 🌾\n")

# Call the function to continuously take input and predict
predict_irrigation()